
--- Module generated by B2Maude (2022-12-20)
--- Context: 
--- Machine: 

--- MAX-STEPS for the simulation: 10000

load ./m-theory/ebmachine .

mod ctxDiceProgram1 is
  inc EBMACHINE .
  pr APMAUDE .

  --- Context: Sets and constants
  eq init-sets = 
   ('STATES |-> gen-set(("s0" "s1" "s2" "s3" "s4" "s5" "s6" "s7")))
  .

  eq init-constants = 
  empty 
  .

--- ===============================

--- VARIABLES 
 var $$st : EBType .
 var $$dice : EBType .

--- CONSTANTS 

vars $$CNAME $$MNAME : Qid .
vars $$LEv $$LEv' : LEvent .
var  $$Sets : Map{Qid, EBSet} .
var  $$Cte  : Map{Qid, EBType} .
var  $$WEIGHT : Nat .
var  $$GUARD :  Bool . 

--- ===============================

  eq init-variables(  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > )
   =
    ('st |-> val(elt("s0"))),
   ('dice |-> val(elt(0))) .


----------------------------
--- Event State0Trans
----------------------------

--- Activation of the Event State0Trans
ceq [State0Trans] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ($$LEv ev('State0Trans, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('State0Trans, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('State0Trans, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$st) =b (val(elt("s0")))) 
.

--- Change of state for event State0Trans
rl [State0Trans] :
    {gt | SL} ($$MNAME <- RuleState0Trans) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ( ev('State0Trans, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('dice |-> $$dice , 'st |-> choice( val(elt("s1")) @ 0.5  val(elt("s2")) @ 0.5, myCounter)) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event State1Trans
----------------------------

--- Activation of the Event State1Trans
ceq [State1Trans] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ($$LEv ev('State1Trans, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('State1Trans, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('State1Trans, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$st) =b (val(elt("s1")))) 
.

--- Change of state for event State1Trans
rl [State1Trans] :
    {gt | SL} ($$MNAME <- RuleState1Trans) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ( ev('State1Trans, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('dice |-> $$dice , 'st |-> choice( val(elt("s3")) @ 0.5  val(elt("s4")) @ 0.5, myCounter)) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event State2Trans
----------------------------

--- Activation of the Event State2Trans
ceq [State2Trans] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ($$LEv ev('State2Trans, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('State2Trans, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('State2Trans, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$st) =b (val(elt("s2")))) 
.

--- Change of state for event State2Trans
rl [State2Trans] :
    {gt | SL} ($$MNAME <- RuleState2Trans) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ( ev('State2Trans, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('dice |-> $$dice , 'st |-> choice( val(elt("s5")) @ 0.5  val(elt("s6")) @ 0.5, myCounter)) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event State3Trans1
----------------------------

--- Activation of the Event State3Trans1
ceq [State3Trans1] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ($$LEv ev('State3Trans1, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('State3Trans1, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('State3Trans1, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$st) =b (val(elt("s3")))) 
.

--- Change of state for event State3Trans1
rl [State3Trans1] :
    {gt | SL} ($$MNAME <- RuleState3Trans1) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ( ev('State3Trans1, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('dice |-> $$dice , 'st |-> val(elt("s1"))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event State3Trans2
----------------------------

--- Activation of the Event State3Trans2
ceq [State3Trans2] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ($$LEv ev('State3Trans2, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('State3Trans2, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('State3Trans2, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$st) =b (val(elt("s3")))) 
.

--- Change of state for event State3Trans2
rl [State3Trans2] :
    {gt | SL} ($$MNAME <- RuleState3Trans2) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ( ev('State3Trans2, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('st |-> val(elt("s7")) , 'dice |-> val(elt(1))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event State4Trans
----------------------------

--- Activation of the Event State4Trans
ceq [State4Trans] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ($$LEv ev('State4Trans, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('State4Trans, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('State4Trans, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$st) =b (val(elt("s4")))) 
.

--- Change of state for event State4Trans
rl [State4Trans] :
    {gt | SL} ($$MNAME <- RuleState4Trans) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ( ev('State4Trans, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('st |-> val(elt("s7")) , 'dice |-> choice( val(elt(2)) @ 0.5  val(elt(3)) @ 0.5, myCounter)) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event State5Trans
----------------------------

--- Activation of the Event State5Trans
ceq [State5Trans] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ($$LEv ev('State5Trans, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('State5Trans, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('State5Trans, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$st) =b (val(elt("s5")))) 
.

--- Change of state for event State5Trans
rl [State5Trans] :
    {gt | SL} ($$MNAME <- RuleState5Trans) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ( ev('State5Trans, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('st |-> val(elt("s7")) , 'dice |-> choice( val(elt(4)) @ 0.5  val(elt(5)) @ 0.5, myCounter)) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event State6Trans1
----------------------------

--- Activation of the Event State6Trans1
ceq [State6Trans1] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ($$LEv ev('State6Trans1, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('State6Trans1, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('State6Trans1, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$st) =b (val(elt("s6")))) 
.

--- Change of state for event State6Trans1
rl [State6Trans1] :
    {gt | SL} ($$MNAME <- RuleState6Trans1) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ( ev('State6Trans1, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('dice |-> $$dice , 'st |-> val(elt("s2"))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event State6Trans2
----------------------------

--- Activation of the Event State6Trans2
ceq [State6Trans2] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ($$LEv ev('State6Trans2, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('State6Trans2, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('State6Trans2, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$st) =b (val(elt("s6")))) 
.

--- Change of state for event State6Trans2
rl [State6Trans2] :
    {gt | SL} ($$MNAME <- RuleState6Trans2) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
    < events  : Events  | state: ( ev('State6Trans2, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('st |-> val(elt("s7")) , 'dice |-> val(elt(6))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


  --- Initialization of events
  eq init-events = ev('State0Trans, unknown) ev('State1Trans, unknown) ev('State2Trans, unknown) ev('State3Trans1, unknown) ev('State3Trans2, unknown) ev('State4Trans, unknown) ev('State5Trans, unknown) ev('State6Trans1, unknown) ev('State6Trans2, unknown) .

  --- Rule for choosing the next event to be executed
  --- It stops when the system is in a deadlock or the limit 
  --- MAX-STEPS is reached.
  op MAX-STEPS : -> Float .
  eq MAX-STEPS = 10000.0 .

  --- variables used for Multivesta processes
  var gt : Float .  
  var SL : ScheduleList .
  vars Conf : Configuration .
  var myCounter : Nat . --- counter variable used to generate random numbers

  crl [next-event] :
     {Conf < events : Events | state: ($$LEv) > randomCounter(myCounter)} {gt | SL} 
     =>
     scheduleEvent({ Conf < events : Events | state: choose-event($$LEv', s(myCounter)) > randomCounter(s(myCounter))} {gt | SL}) 
  if
        gt <= MAX-STEPS
    /\  not-unknown($$LEv) --- all the guards have been checked
    /\  one-firable($$LEv) --- one of the events is firable
    /\  $$LEv' := accumulate(enabled-events($$LEv)) --- extract the enabled events and accumulate
  .

  --- ---------------------------------------------------------------
  --- MultiVeStA ----------------------------------------------------
  --- ---------------------------------------------------------------

  --- Contents -------------------------------------------------------

  op qidToContent : Qid -> Content .


op RuleState0Trans : -> Content [ ctor ] .
op RuleState1Trans : -> Content [ ctor ] .
op RuleState2Trans : -> Content [ ctor ] .
op RuleState3Trans1 : -> Content [ ctor ] .
op RuleState3Trans2 : -> Content [ ctor ] .
op RuleState4Trans : -> Content [ ctor ] .
op RuleState5Trans : -> Content [ ctor ] .
op RuleState6Trans1 : -> Content [ ctor ] .
op RuleState6Trans2 : -> Content [ ctor ] .

eq qidToContent('State0Trans) =  RuleState0Trans .
eq qidToContent('State1Trans) =  RuleState1Trans .
eq qidToContent('State2Trans) =  RuleState2Trans .
eq qidToContent('State3Trans1) =  RuleState3Trans1 .
eq qidToContent('State3Trans2) =  RuleState3Trans2 .
eq qidToContent('State4Trans) =  RuleState4Trans .
eq qidToContent('State5Trans) =  RuleState5Trans .
eq qidToContent('State6Trans1) =  RuleState6Trans1 .
eq qidToContent('State6Trans2) =  RuleState6Trans2 .




  --- ---------------------------------------------------------------

  --- Scheduler Equations --------------------------------------------
  var ruleQid : Qid .
  op scheduleEvent : Configuration -> Configuration .
  eq scheduleEvent( { gt | SL }
                    { < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) >  
                      < events  : Events  | state: ( ev(ruleQid, execute) ) > 
                      randomCounter(myCounter)} )
                    =
                    insert({ gt | SL },[ gt + 1.0 , ($$MNAME <- qidToContent(ruleQid)),0])
                    { < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) > 
                      < events  : Events  | state: ( ev(ruleQid, execute) ) > 
                      randomCounter(myCounter)} .

  --- -----------------------------------------------------------------

  --- Predefined State Observations -----------------------------------
  --- s.rval("steps") and s.rval("time") return the number of events executed (defined inside MultiVeStA)

  --- s.rval("isMax") returns 1.0 when the simulation's time (i.e number of system transitions 
  --- or executed events) has reached MAX-STEPS, 0.0 otherwise
  eq val("isMax", {Conf} {gt | SL}) = if (gt >= MAX-STEPS) then 1.0 else 0.0 fi .

  --- s.rval("deadlock") returns 1.0 when there are no more enabled events, 0.0 otherwise
  eq val("deadlock", {Conf < events : Events | state: ($$LEv) >} 
                     {gt | SL}) = if (not-unknown($$LEv) and not(one-firable($$LEv))) 
                                                  then 1.0 else 0.0 fi .
  --- -----------------------------------------------------------------

  --- User Defined Observations --------------------------------------- 

eq val("obs1", {Conf < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) >} {gt | SL}  ) 
  = toFloat((($$dice) =b (val(elt(1))))) .

eq val("obs2", {Conf < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) >} {gt | SL}  ) 
  = toFloat((($$dice) =b (val(elt(2))))) .

eq val("obs3", {Conf < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) >} {gt | SL}  ) 
  = toFloat((($$dice) =b (val(elt(3))))) .

eq val("obs4", {Conf < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) >} {gt | SL}  ) 
  = toFloat((($$dice) =b (val(elt(4))))) .

eq val("obs5", {Conf < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) >} {gt | SL}  ) 
  = toFloat((($$dice) =b (val(elt(5))))) .

eq val("obs6", {Conf < $$MNAME : Machine | variables: ('st |-> $$st , 'dice |-> $$dice) >} {gt | SL}  ) 
  = toFloat((($$dice) =b (val(elt(6))))) .

  --- -----------------------------------------------------------------


  --- Defining the initial state---------------------------------------
  op init : -> Configuration .
  eq init =  {0.0 | nilSL} init-machine('ctxDiceProgram1, 'DiceProgram1) randomCounter(0) .
  ---------------------------------------------------------------------

endm

eof

