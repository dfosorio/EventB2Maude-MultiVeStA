
--- Module generated by B2Maude (2023-04-18)
--- Context: 
--- Machine: 

--- MAX-STEPS for the simulation: 10000

load ./m-theory/ebmachine .

mod ctxPNL is
  inc EBMACHINE .
  pr APMAUDE .

  --- Context: Sets and constants
  eq init-sets = 
   ('AGENTS |-> gen-set(("a" "b" "c" "d" "e")))
  .

  eq init-constants = 
  empty 
  .

--- ===============================

--- VARIABLES 
 var $$AgentsComb : EBType .
 var $$Rpositive : EBType .
 var $$Rnegative : EBType .

--- CONSTANTS 

vars $$CNAME $$MNAME : Qid .
vars $$LEv $$LEv' : LEvent .
var  $$Sets : Map{Qid, EBSet} .
var  $$Cte  : Map{Qid, EBType} .
var  $$WEIGHT : Nat .
var  $$GUARD :  Bool . 

--- ===============================

  eq init-variables(  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > )
   =
    ('AgentsComb |-> val( ( elt("a") |-> elt("b") , elt("a") |-> elt("c") , elt("a") |-> elt("d") , elt("a") |-> elt("e") , elt("b") |-> elt("c") , elt("b") |-> elt("d") , elt("b") |-> elt("e") , elt("c") |-> elt("d") , elt("c") |-> elt("e") , elt("d") |-> elt("e") ) )),
   ('Rpositive |-> val( ( elt("a") |-> elt("b") , elt("a") |-> elt("e") , elt("b") |-> elt("c") , elt("b") |-> elt("d") , elt("c") |-> elt("d") ) )),
   ('Rnegative |-> val( ( elt("a") |-> elt("c") , elt("a") |-> elt("d") ) )) .


----------------------------
--- Event addPositiveEdge
----------------------------

--- Activation of the Event addPositiveEdge
ceq [addPositiveEdge] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> $$Rnegative) > 
    < events  : Events  | state: ($$LEv ev('addPositiveEdge, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> $$Rnegative) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('addPositiveEdge, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('addPositiveEdge, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(val(elt(true)))  and  is-empty( (( ( ($$AgentsComb) \ ($$Rpositive) )) \ ($$Rnegative)) ) == false 
.

--- Change of state for event addPositiveEdge
rl [addPositiveEdge] :
    {gt | SL} ($$MNAME <- RuleaddPositiveEdge) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> $$Rnegative) > 
    < events  : Events  | state: ( ev('addPositiveEdge, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rnegative |-> $$Rnegative , 'Rpositive |-> union($$Rpositive, choice(( ( ($$AgentsComb) \ ($$Rpositive) )) \ ($$Rnegative), myCounter))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event addNegativeEdge
----------------------------

--- Activation of the Event addNegativeEdge
ceq [addNegativeEdge] :
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> $$Rnegative) > 
    < events  : Events  | state: ($$LEv ev('addNegativeEdge, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> $$Rnegative) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('addNegativeEdge, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('addNegativeEdge, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(val(elt(true)))  and  is-empty( (( ( ($$AgentsComb) \ ($$Rpositive) )) \ ($$Rnegative)) ) == false 
.

--- Change of state for event addNegativeEdge
rl [addNegativeEdge] :
    {gt | SL} ($$MNAME <- RuleaddNegativeEdge) 
    {< $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
  < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> $$Rnegative) > 
    < events  : Events  | state: ( ev('addNegativeEdge, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> union($$Rnegative, choice(( ( ($$AgentsComb) \ ($$Rpositive) )) \ ($$Rnegative), myCounter))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


  --- Initialization of events
  eq init-events = ev('addPositiveEdge, unknown) ev('addNegativeEdge, unknown) .

  --- Rule for choosing the next event to be executed
  --- It stops when the system is in a deadlock or the limit 
  --- MAX-STEPS is reached.
  op MAX-STEPS : -> Float .
  eq MAX-STEPS = 10000.0 .

  --- variables used for Multivesta processes
  var gt : Float .  
  var SL : ScheduleList .
  vars Conf : Configuration .
  var myCounter : Nat . --- counter variable used to generate random numbers

  crl [next-event] :
     {Conf < events : Events | state: ($$LEv) > randomCounter(myCounter)} {gt | SL} 
     =>
     scheduleEvent({ Conf < events : Events | state: choose-event($$LEv', s(myCounter)) > randomCounter(s(myCounter))} {gt | SL}) 
  if
        gt <= MAX-STEPS
    /\  not-unknown($$LEv) --- all the guards have been checked
    /\  one-firable($$LEv) --- one of the events is firable
    /\  $$LEv' := accumulate(enabled-events($$LEv)) --- extract the enabled events and accumulate
  .

  --- ---------------------------------------------------------------
  --- MultiVeStA ----------------------------------------------------
  --- ---------------------------------------------------------------

  --- Contents -------------------------------------------------------

  op qidToContent : Qid -> Content .


op RuleaddPositiveEdge : -> Content [ ctor ] .
op RuleaddNegativeEdge : -> Content [ ctor ] .

eq qidToContent('addPositiveEdge) =  RuleaddPositiveEdge .
eq qidToContent('addNegativeEdge) =  RuleaddNegativeEdge .




  --- ---------------------------------------------------------------

  --- Scheduler Equations --------------------------------------------
  var ruleQid : Qid .
  op scheduleEvent : Configuration -> Configuration .
  eq scheduleEvent( { gt | SL }
                    { < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> $$Rnegative) >  
                      < events  : Events  | state: ( ev(ruleQid, execute) ) > 
                      randomCounter(myCounter)} )
                    =
                    insert({ gt | SL },[ gt + 1.0 , ($$MNAME <- qidToContent(ruleQid)),0])
                    { < $$CNAME : Context | sets: ($$Sets), constants: (empty) > 
    < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> $$Rnegative) > 
                      < events  : Events  | state: ( ev(ruleQid, execute) ) > 
                      randomCounter(myCounter)} .

  --- -----------------------------------------------------------------

  --- Predefined State Observations -----------------------------------
  --- s.rval("steps") and s.rval("time") return the number of events executed (defined inside MultiVeStA)

  --- s.rval("isMax") returns 1.0 when the simulation's time (i.e number of system transitions 
  --- or executed events) has reached MAX-STEPS, 0.0 otherwise
  eq val("isMax", {Conf} {gt | SL}) = if (gt >= MAX-STEPS) then 1.0 else 0.0 fi .

  --- s.rval("deadlock") returns 1.0 when there are no more enabled events, 0.0 otherwise
  eq val("deadlock", {Conf < events : Events | state: ($$LEv) >} 
                     {gt | SL}) = if (not-unknown($$LEv) and not(one-firable($$LEv))) 
                                                  then 1.0 else 0.0 fi .
  --- -----------------------------------------------------------------

--- User Defined Observations ---------------------------------------

  --- Definition of triangle sort
  sort Triangle .
  sort TriangleList .
  subsort Triangle < TriangleList .

  op triangle : EBPair EBPair EBPair -> Triangle [ctor] .
  op emptyList : -> TriangleList [ctor] .
  op _,_ : TriangleList TriangleList -> TriangleList [ctor assoc comm id: emptyList] .

  --- Set of all triangles (harcoded for the moment)

  op allTriangles : -> TriangleList .
  eq allTriangles = ( triangle(elt("a") |-> elt("b"), elt("b") |-> elt("c"), elt("a") |-> elt("c")), --- (a,b,c)
                      triangle(elt("a") |-> elt("b"), elt("b") |-> elt("d"), elt("a") |-> elt("d")), --- (a,b,d)
                      triangle(elt("a") |-> elt("b"), elt("b") |-> elt("e"), elt("a") |-> elt("e")), --- (a,b,e)
                      triangle(elt("a") |-> elt("c"), elt("c") |-> elt("d"), elt("a") |-> elt("d")), --- (a,c,d)
                      triangle(elt("a") |-> elt("c"), elt("c") |-> elt("e"), elt("a") |-> elt("e")), --- (a,c,e)
                      triangle(elt("a") |-> elt("d"), elt("d") |-> elt("e"), elt("a") |-> elt("e")), --- (a,d,e)
                      triangle(elt("b") |-> elt("c"), elt("c") |-> elt("d"), elt("b") |-> elt("d")), --- (b,c,d)
                      triangle(elt("b") |-> elt("c"), elt("c") |-> elt("e"), elt("b") |-> elt("e")), --- (b,c,e)
                      triangle(elt("b") |-> elt("d"), elt("d") |-> elt("e"), elt("b") |-> elt("e")), --- (b,d,e)
                      triangle(elt("c") |-> elt("d"), elt("d") |-> elt("e"), elt("c") |-> elt("e"))  --- (c,d,e)
                    ) .

  --- Balanced triangle property 
  vars E1 E2 E3 : EBPair .
  vars Rpos Rneg : EBRel .  

  op is-balanced : Triangle EBRel EBRel -> Bool .
  eq is-balanced(triangle(E1, E2, E3), Rpos, Rneg) = if ( (E1 in Rpos) and (E2 in Rpos) and (E3 in Rpos) ) or --- (+,+,+)
                                                        ( (E1 in Rpos) and (E2 in Rneg) and (E3 in Rneg) ) or --- (+,-,-)
                                                        ( (E1 in Rneg) and (E2 in Rpos) and (E3 in Rneg) ) or --- (-,+,-)
                                                        ( (E1 in Rneg) and (E2 in Rneg) and (E3 in Rpos) )    --- (-,-,+)
                                                     then true else false fi .

  --- Balanced graph
  var t : Triangle .
  var TL : TriangleList .

  op Balanced : TriangleList EBRel EBRel -> Float .
  eq Balanced(emptyList, Rpos, Rneg) = 1.0 . --- if reaches end, then is balanced
  eq Balanced((t, TL), Rpos, Rneg) = if is-balanced(t, Rpos, Rneg) then Balanced(TL, Rpos, Rneg) else 0.0 fi .

  --- auxiliary function to get an equation
  var R : EBRel .
  op getRel : EBType -> EBRel .
  eq getRel(val(R)) = R .

  eq val("balanced", {Conf < $$MNAME : Machine | variables: ('AgentsComb |-> $$AgentsComb , 'Rpositive |-> $$Rpositive , 'Rnegative |-> $$Rnegative) >} {gt | SL}  ) 
  = Balanced(allTriangles, getRel($$Rpositive), getRel($$Rnegative)) .
  --- -----------------------------------------------------------------



  --- Defining the initial state---------------------------------------
  op init : -> Configuration .
  eq init =  {0.0 | nilSL} init-machine('ctxPNL, 'PNL) randomCounter(0) .
  ---------------------------------------------------------------------

endm

eof

