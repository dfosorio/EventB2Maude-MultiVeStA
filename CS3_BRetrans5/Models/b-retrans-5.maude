
--- Module generated by B2Maude (2023-01-11)
--- Context: 
--- Machine: 

--- MAX-STEPS for the simulation: 10000

load ./m-theory/ebmachine .

mod ctxBRTP is
  inc EBMACHINE .
  pr APMAUDE .

  --- Context: Sets and constants
  eq init-sets = 
   ('STATE |-> gen-set(("working" "success" "failure"))),
   ('DATA |-> gen-set(("D1" "D2")))
  .

  eq init-constants = 
   ('N |-> val(elt(100))),
   ('MAX |-> val(elt(20)))
  .

--- ===============================

--- VARIABLES 
 var $$r : EBType .
 var $$g : EBType .
 var $$rst : EBType .
 var $$sst : EBType .
 var $$s : EBType .
 var $$d : EBType .
 var $$w : EBType .
 var $$db : EBType .
 var $$ab : EBType .
 var $$v : EBType .
 var $$l : EBType .
 var $$c : EBType .

--- CONSTANTS 
 var $$N : EBType .
 var $$MAX : EBType .

vars $$CNAME $$MNAME : Qid .
vars $$LEv $$LEv' : LEvent .
var  $$Sets : Map{Qid, EBSet} .
var  $$Cte  : Map{Qid, EBType} .
var  $$WEIGHT : Nat .
var  $$GUARD :  Bool . 

--- ===============================

  eq init-variables(  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > )
   =
    ('r |-> val(elt(0))),
   ('g |-> val((empty).EBRel)),
   ('rst |-> val(elt("working"))),
   ('sst |-> val(elt("working"))),
   ('s |-> val(elt(0))),
   ('d |-> val(elt("D1"))),
   ('w |-> val(elt(true))),
   ('db |-> val(elt(false))),
   ('ab |-> val(elt(false))),
   ('v |-> val(elt(false))),
   ('l |-> val(elt(false))),
   ('c |-> val(elt(0))) .


----------------------------
--- Event SNDsndcurrentdata
----------------------------

--- Activation of the Event SNDsndcurrentdata
ceq [SNDsndcurrentdata] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('SNDsndcurrentdata, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('SNDsndcurrentdata, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('SNDsndcurrentdata, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(((($$sst) =b (val(elt("working")))) andb (($$w) =b (val(elt(true))))) andb ((($$s) + (val(elt(1)))) < ($$N))) 
.

--- Change of state for event SNDsndcurrentdata
rl [SNDsndcurrentdata] :
    {gt | SL} ($$MNAME <- RuleSNDsndcurrentdata) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('SNDsndcurrentdata, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'ab |-> $$ab , 'v |-> $$v , 'c |-> $$c , 'd |-> val(elt("D2")) , 'w |-> val(elt(false)) , 'db |-> val(elt(true)) , 'l |-> val(elt(false))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event SNDsndlastdata
----------------------------

--- Activation of the Event SNDsndlastdata
ceq [SNDsndlastdata] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('SNDsndlastdata, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('SNDsndlastdata, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('SNDsndlastdata, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(((($$sst) =b (val(elt("working")))) andb (($$w) =b (val(elt(true))))) andb ((($$s) + (val(elt(1)))) =b ($$N))) 
.

--- Change of state for event SNDsndlastdata
rl [SNDsndlastdata] :
    {gt | SL} ($$MNAME <- RuleSNDsndlastdata) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('SNDsndlastdata, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'ab |-> $$ab , 'v |-> $$v , 'c |-> $$c , 'd |-> val(elt("D2")) , 'w |-> val(elt(false)) , 'db |-> val(elt(true)) , 'l |-> val(elt(true))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event RCVrcvcurdata
----------------------------

--- Activation of the Event RCVrcvcurdata
ceq [RCVrcvcurdata] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('RCVrcvcurdata, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('RCVrcvcurdata, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('RCVrcvcurdata, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool((((($$rst) =b (val(elt("working")))) andb (($$db) =b (val(elt(true))))) andb (($$r) =b ($$s))) andb (($$l) =b (val(elt(false))))) 
.

--- Change of state for event RCVrcvcurdata
rl [RCVrcvcurdata] :
    {gt | SL} ($$MNAME <- RuleRCVrcvcurdata) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('RCVrcvcurdata, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'ab |-> $$ab , 'l |-> $$l , 'c |-> $$c , 'r |-> ($$r) + (val(elt(1))) , 'g |-> overr($$g, val( ( $$r |-> $$d ) )) , 'db |-> val(elt(false)) , 'v |-> val(elt(true))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event RCVsuccess
----------------------------

--- Activation of the Event RCVsuccess
ceq [RCVsuccess] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('RCVsuccess, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('RCVsuccess, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('RCVsuccess, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool((((($$rst) =b (val(elt("working")))) andb (($$db) =b (val(elt(true))))) andb (($$r) =b ($$s))) andb (($$l) =b (val(elt(true))))) 
.

--- Change of state for event RCVsuccess
rl [RCVsuccess] :
    {gt | SL} ($$MNAME <- RuleRCVsuccess) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('RCVsuccess, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'ab |-> $$ab , 'l |-> $$l , 'c |-> $$c , 'rst |-> val(elt("success")) , 'r |-> ($$r) + (val(elt(1))) , 'g |-> overr($$g, val( ( $$r |-> $$d ) )) , 'db |-> val(elt(false)) , 'v |-> val(elt(true))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event RCVrcvretry
----------------------------

--- Activation of the Event RCVrcvretry
ceq [RCVrcvretry] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('RCVrcvretry, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('RCVrcvretry, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('RCVrcvretry, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool((($$db) =b (val(elt(true)))) andb (($$r) <>b ($$s))) 
.

--- Change of state for event RCVrcvretry
rl [RCVrcvretry] :
    {gt | SL} ($$MNAME <- RuleRCVrcvretry) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('RCVrcvretry, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'ab |-> $$ab , 'l |-> $$l , 'c |-> $$c , 'db |-> val(elt(false)) , 'v |-> val(elt(true))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event RCVsndack
----------------------------

--- Activation of the Event RCVsndack
ceq [RCVsndack] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('RCVsndack, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('RCVsndack, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('RCVsndack, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$v) =b (val(elt(true)))) 
.

--- Change of state for event RCVsndack
rl [RCVsndack] :
    {gt | SL} ($$MNAME <- RuleRCVsndack) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('RCVsndack, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'l |-> $$l , 'c |-> $$c , 'v |-> val(elt(false)) , 'ab |-> val(elt(true))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event SNDrcvcuracl
----------------------------

--- Activation of the Event SNDrcvcuracl
ceq [SNDrcvcuracl] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('SNDrcvcuracl, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('SNDrcvcuracl, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('SNDrcvcuracl, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(((($$sst) =b (val(elt("working")))) andb (($$ab) =b (val(elt(true))))) andb ((($$s) + (val(elt(1)))) < ($$N))) 
.

--- Change of state for event SNDrcvcuracl
rl [SNDrcvcuracl] :
    {gt | SL} ($$MNAME <- RuleSNDrcvcuracl) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('SNDrcvcuracl, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 'd |-> $$d , 'db |-> $$db , 'v |-> $$v , 'l |-> $$l , 'w |-> val(elt(true)) , 's |-> ($$s) + (val(elt(1))) , 'c |-> val(elt(0)) , 'ab |-> val(elt(false))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event SNDsuccess
----------------------------

--- Activation of the Event SNDsuccess
ceq [SNDsuccess] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('SNDsuccess, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('SNDsuccess, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('SNDsuccess, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(((($$sst) =b (val(elt("working")))) andb (($$ab) =b (val(elt(true))))) andb ((($$s) + (val(elt(1)))) =b ($$N))) 
.

--- Change of state for event SNDsuccess
rl [SNDsuccess] :
    {gt | SL} ($$MNAME <- RuleSNDsuccess) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('SNDsuccess, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'v |-> $$v , 'l |-> $$l , 'sst |-> val(elt("success")) , 'c |-> val(elt(0)) , 'ab |-> val(elt(false))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event DMNdatach
----------------------------

--- Activation of the Event DMNdatach
ceq [DMNdatach] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('DMNdatach, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('DMNdatach, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('DMNdatach, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$db) =b (val(elt(true)))) 
.

--- Change of state for event DMNdatach
rl [DMNdatach] :
    {gt | SL} ($$MNAME <- RuleDMNdatach) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('DMNdatach, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c , 'db |-> val(elt(false))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event DMNack
----------------------------

--- Activation of the Event DMNack
ceq [DMNack] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('DMNack, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('DMNack, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('DMNack, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(($$ab) =b (val(elt(true)))) 
.

--- Change of state for event DMNack
rl [DMNack] :
    {gt | SL} ($$MNAME <- RuleDMNack) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('DMNack, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c , 'ab |-> val(elt(false))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event SNDtimeout
----------------------------

--- Activation of the Event SNDtimeout
ceq [SNDtimeout] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('SNDtimeout, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('SNDtimeout, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('SNDtimeout, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool((((((($$sst) =b (val(elt("working")))) andb (($$w) =b (val(elt(false))))) andb (($$ab) =b (val(elt(false))))) andb (($$db) =b (val(elt(false))))) andb (($$v) =b (val(elt(false))))) andb (($$c) < ($$MAX))) 
.

--- Change of state for event SNDtimeout
rl [SNDtimeout] :
    {gt | SL} ($$MNAME <- RuleSNDtimeout) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('SNDtimeout, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'w |-> val(elt(true)) , 'c |-> ($$c) + (val(elt(1)))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event SNDfailure
----------------------------

--- Activation of the Event SNDfailure
ceq [SNDfailure] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('SNDfailure, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('SNDfailure, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('SNDfailure, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool((((((($$sst) =b (val(elt("working")))) andb (($$w) =b (val(elt(false))))) andb (($$ab) =b (val(elt(false))))) andb (($$db) =b (val(elt(false))))) andb (($$v) =b (val(elt(false))))) andb (($$c) =b ($$MAX))) 
.

--- Change of state for event SNDfailure
rl [SNDfailure] :
    {gt | SL} ($$MNAME <- RuleSNDfailure) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('SNDfailure, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'sst |-> val(elt("failure")) , 'c |-> ($$c) + (val(elt(1)))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


----------------------------
--- Event RCVfailure
----------------------------

--- Activation of the Event RCVfailure
ceq [RCVfailure] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('RCVfailure, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('RCVfailure, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('RCVfailure, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool((($$rst) =b (val(elt("working")))) andb (($$c) =b (($$MAX) + (val(elt(1)))))) 
.

--- Change of state for event RCVfailure
rl [RCVfailure] :
    {gt | SL} ($$MNAME <- RuleRCVfailure) 
    {< $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
  < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('RCVfailure, execute) ) >
    randomCounter(myCounter)}
    =>
    {gt | SL}
    {  < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c , 'rst |-> val(elt("failure"))) > 
    < events : Events | state: init-events >
    randomCounter(myCounter)}
    .


  --- Initialization of events
  eq init-events = ev('SNDsndcurrentdata, unknown) ev('SNDsndlastdata, unknown) ev('RCVrcvcurdata, unknown) ev('RCVsuccess, unknown) ev('RCVrcvretry, unknown) ev('RCVsndack, unknown) ev('SNDrcvcuracl, unknown) ev('SNDsuccess, unknown) ev('DMNdatach, unknown) ev('DMNack, unknown) ev('SNDtimeout, unknown) ev('SNDfailure, unknown) ev('RCVfailure, unknown) .

  --- Rule for choosing the next event to be executed
  --- It stops when the system is in a deadlock or the limit 
  --- MAX-STEPS is reached.
  op MAX-STEPS : -> Float .
  eq MAX-STEPS = 10000.0 .

  --- variables used for Multivesta processes
  var gt : Float .  
  var SL : ScheduleList .
  vars Conf : Configuration .
  var myCounter : Nat . --- counter variable used to generate random numbers

  crl [next-event] :
     {Conf < events : Events | state: ($$LEv) > randomCounter(myCounter)} {gt | SL} 
     =>
     scheduleEvent({ Conf < events : Events | state: choose-event($$LEv', s(myCounter)) > randomCounter(s(myCounter))} {gt | SL}) 
  if
        gt <= MAX-STEPS
    /\  not-unknown($$LEv) --- all the guards have been checked
    /\  one-firable($$LEv) --- one of the events is firable
    /\  $$LEv' := accumulate(enabled-events($$LEv)) --- extract the enabled events and accumulate
  .

  --- ---------------------------------------------------------------
  --- MultiVeStA ----------------------------------------------------
  --- ---------------------------------------------------------------

  --- Contents -------------------------------------------------------

  op qidToContent : Qid -> Content .


op RuleSNDsndcurrentdata : -> Content [ ctor ] .
op RuleSNDsndlastdata : -> Content [ ctor ] .
op RuleRCVrcvcurdata : -> Content [ ctor ] .
op RuleRCVsuccess : -> Content [ ctor ] .
op RuleRCVrcvretry : -> Content [ ctor ] .
op RuleRCVsndack : -> Content [ ctor ] .
op RuleSNDrcvcuracl : -> Content [ ctor ] .
op RuleSNDsuccess : -> Content [ ctor ] .
op RuleDMNdatach : -> Content [ ctor ] .
op RuleDMNack : -> Content [ ctor ] .
op RuleSNDtimeout : -> Content [ ctor ] .
op RuleSNDfailure : -> Content [ ctor ] .
op RuleRCVfailure : -> Content [ ctor ] .

eq qidToContent('SNDsndcurrentdata) =  RuleSNDsndcurrentdata .
eq qidToContent('SNDsndlastdata) =  RuleSNDsndlastdata .
eq qidToContent('RCVrcvcurdata) =  RuleRCVrcvcurdata .
eq qidToContent('RCVsuccess) =  RuleRCVsuccess .
eq qidToContent('RCVrcvretry) =  RuleRCVrcvretry .
eq qidToContent('RCVsndack) =  RuleRCVsndack .
eq qidToContent('SNDrcvcuracl) =  RuleSNDrcvcuracl .
eq qidToContent('SNDsuccess) =  RuleSNDsuccess .
eq qidToContent('DMNdatach) =  RuleDMNdatach .
eq qidToContent('DMNack) =  RuleDMNack .
eq qidToContent('SNDtimeout) =  RuleSNDtimeout .
eq qidToContent('SNDfailure) =  RuleSNDfailure .
eq qidToContent('RCVfailure) =  RuleRCVfailure .




  --- ---------------------------------------------------------------

  --- Scheduler Equations --------------------------------------------
  var ruleQid : Qid .
  op scheduleEvent : Configuration -> Configuration .
  eq scheduleEvent( { gt | SL }
                    { < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) >  
                      < events  : Events  | state: ( ev(ruleQid, execute) ) > 
                      randomCounter(myCounter)} )
                    =
                    insert({ gt | SL },[ gt + 1.0 , ($$MNAME <- qidToContent(ruleQid)),0])
                    { < $$CNAME : Context | sets: ($$Sets), constants: ('N |-> $$N , 'MAX |-> $$MAX) > 
    < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) > 
                      < events  : Events  | state: ( ev(ruleQid, execute) ) > 
                      randomCounter(myCounter)} .

  --- -----------------------------------------------------------------

  --- Predefined State Observations -----------------------------------
  --- s.rval("steps") and s.rval("time") return the number of events executed (defined inside MultiVeStA)

  --- s.rval("isMax") returns 1.0 when the simulation's time (i.e number of system transitions 
  --- or executed events) has reached MAX-STEPS, 0.0 otherwise
  eq val("isMax", {Conf} {gt | SL}) = if (gt >= MAX-STEPS) then 1.0 else 0.0 fi .

  --- s.rval("deadlock") returns 1.0 when there are no more enabled events, 0.0 otherwise
  eq val("deadlock", {Conf < events : Events | state: ($$LEv) >} 
                     {gt | SL}) = if (not-unknown($$LEv) and not(one-firable($$LEv))) 
                                                  then 1.0 else 0.0 fi .
  --- -----------------------------------------------------------------

  --- User Defined Observations --------------------------------------- 

eq val("obs1", {Conf < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) >} {gt | SL}  ) 
  = toFloat(((($$sst) =b (val(elt("failure")))) andb (($$rst) =b (val(elt("failure")))))) .

eq val("obs2", {Conf < $$MNAME : Machine | variables: ('r |-> $$r , 'g |-> $$g , 'rst |-> $$rst , 'sst |-> $$sst , 's |-> $$s , 'd |-> $$d , 'w |-> $$w , 'db |-> $$db , 'ab |-> $$ab , 'v |-> $$v , 'l |-> $$l , 'c |-> $$c) >} {gt | SL}  ) 
  = toFloat(((($$sst) =b (val(elt("success")))) andb (($$rst) =b (val(elt("success")))))) .

  --- -----------------------------------------------------------------


  --- Defining the initial state---------------------------------------
  op init : -> Configuration .
  eq init =  {0.0 | nilSL} init-machine('ctxBRTP, 'BRTP) randomCounter(0) .
  ---------------------------------------------------------------------

endm

eof

